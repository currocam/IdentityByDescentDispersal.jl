var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#IdentityByDescentDispersal.composite_loglikelihood_constant_density","page":"Reference","title":"IdentityByDescentDispersal.composite_loglikelihood_constant_density","text":"composite_loglikelihood_constant_density(D::Real, sigma::Real, df::DataFrame, contig_lengths::AbstractArray{<:Real}, chromosomal_edges::Bool=true, diploid::Bool=true) -> Real\n\nComputes the composite log-likelihood of the observed IBD blocks under a model with constant population density.\n\nD: Effective population density (diploid individuals per unit area).\nsigma: Root mean square dispersal distance per generation.\ndf: DataFrame containing the observed IBD blocks in the format returned by preprocess_dataset.\ncontig_lengths: Array of contig lengths in Morgans.\n\nOptionally:\n\nchromosomal_edges: Whether to account for chromosomal edge effects.\ndiploid: Whether to account for diploidy.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.composite_loglikelihood_custom","page":"Reference","title":"IdentityByDescentDispersal.composite_loglikelihood_custom","text":"composite_loglikelihood_custom(De::Function, parameters::AbstractArray, sigma::Real, df::DataFrame, contig_lengths::AbstractArray{<:Real}, chromosomal_edges::Bool=true, diploid::Bool=true) -> Real\n\nComputes the composite log-likelihood of the observed IBD blocks under a model with constant population density.\n\nDe is  a user defined function that takes time t and a parameters and returns the effective population density at time t.\nparameters is a user defined array of parameters that the function De depends on.\nsigma: Root mean square dispersal distance per generation.\ndf: DataFrame containing the observed IBD blocks in the format returned by preprocess_dataset.\ncontig_lengths: Array of contig lengths in Morgans.\n\nOptionally:\n\nchromosomal_edges: Whether to account for chromosomal edge effects.\ndiploid: Whether to account for diploidy.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.composite_loglikelihood_power_density","page":"Reference","title":"IdentityByDescentDispersal.composite_loglikelihood_power_density","text":"composite_loglikelihood_power_density(D::Real, beta::Real, sigma::Real, df::DataFrame, contig_lengths::AbstractArray{<:Real}, chromosomal_edges::Bool=true, diploid::Bool=true) -> Real\n\nComputes the composite log-likelihood of the observed IBD blocks under a model with constant population density.\n\nD: Effective population density (diploid individuals per unit area).\nbeta is the power of the density function,\nsigma: Root mean square dispersal distance per generation.\ndf: DataFrame containing the observed IBD blocks in the format returned by preprocess_dataset.\ncontig_lengths: Array of contig lengths in Morgans.\n\nOptionally:\n\nchromosomal_edges: Whether to account for chromosomal edge effects.\ndiploid: Whether to account for diploidy.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.expected_ibd_blocks_constant_density","page":"Reference","title":"IdentityByDescentDispersal.expected_ibd_blocks_constant_density","text":"expected_ibd_blocks_constant_density(r::Real, D::Real, sigma::Real, L::Real, G::Real, chromosomal_edges::Bool=true, diploid::Bool=true) -> Real\n\nComputes the expected number of identity-by-descent (IBD) blocks of length L for a model with constant population density.\n\nmathbbEN_L = int_0^infty mathbbEN_L^t dt =\nfracG8pi D sigma^2\nleft(fracrsqrtL sigmaright)^2\nK_2left(fracsqrt2L  rsigmaright)\n\nwhere:\n\nr is the geographic distance between samples,\nD is the effective population density (diploid individuals per unit area),\nsigma is the root mean square dispersal distance per generation,\nL is the minimum length of the IBD block (in Morgans),\nG is the total map length of the genome (in Morgans),\nK₂ is the modified Bessel function of the second kind of order 2.\n\nIf chromosomal_edges is true (the default), we account for chromosomal edge effects. If diploid is true, we multiply by a factor of 4 to account for the fact that each individual has two copies of each chromosome. For more details, see Appendix B.\n\nThere is a function overload that accepts a vector of G values and returns the aggregated expected number of IBD blocks.\n\nReference: Ringbauer, H., Coop, G., & Barton, N. H. (2017). Genetics, 205(3), 1335–1351.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.expected_ibd_blocks_custom","page":"Reference","title":"IdentityByDescentDispersal.expected_ibd_blocks_custom","text":"expected_ibd_blocks_custom(r::Real, De::Function, parameters::AbstractArray, sigma::Real, L::Real, G::Real, chromosomal_edges::Bool = true, diploid::Bool = true)\n\nComputes the expected number of identity-by-descent (IBD) blocks of length L for a model where the effective population density is given by a custom function De(t, parameters).\n\nmathbbEN_L = int_0^infty mathbbEN_L^t dt = int_0^infty mathbbEN_L^t dt  G  4t^2 exp(-2Lt) cdot Phi(t) dt\n\nThe integral is computed numerically using Gaussian-Legendre quadrature rules with the QuadGK package.\n\nwhere:\n\nr is the geographic distance between samples,\nDe is  a user defined function that takes time t and a parameters and returns the effective population density at time t.\nparameters is a user defined array of parameters that the function De depends on.\nsigma is the root mean square dispersal distance per generation,\nL is the minimum length of the IBD block (in Morgans),\nG is the total map length of the genome (in Morgans),\nK₂ is the modified Bessel function of the second kind of order 2.\n\nIf chromosomal_edges is true (the default), we account for chromosomal edge effects. If diploid is true, we multiply by a factor of 4 to account for the fact that each individual has two copies of each chromosome. For more details, see Appendix B.\n\nReference: Ringbauer, H., Coop, G., & Barton, N. H. (2017). Genetics, 205(3), 1335–1351.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.expected_ibd_blocks_power_density","page":"Reference","title":"IdentityByDescentDispersal.expected_ibd_blocks_power_density","text":"expected_ibd_blocks_power_density(r::Real, D::Real, beta::Real, sigma::Real, L::Real, G::Real, chromosomal_edges::Bool = true, diploid::Bool = true)\n\nComputes the expected number of identity-by-descent (IBD) blocks of length L for a model with a power population density in the form of D(t) = D_0t^-beta\n\nmathbbEN_L = int_0^infty mathbbEN_L^t dt =\n2^frac-3beta2-3\nfracGpi D sigma^2\nleft(fracrsqrtL sigmaright)^(2+beta)\nK_2+betaleft(fracsqrt2L  rsigmaright)\n\nwhere:\n\nr is the geographic distance between samples,\nD is the effective population density (diploid individuals per unit area),\nbeta is the power of the density function,\nsigma is the root mean square dispersal distance per generation,\nL is the minimum length of the IBD block (in Morgans),\nG is the total map length of the genome (in Morgans),\nK₂ is the modified Bessel function of the second kind of order 2.\n\nIf chromosomal_edges is true (the default), we account for chromosomal edge effects. If diploid is true, we multiply by a factor of 4 to account for the fact that each individual has two copies of each chromosome. For more details, see Appendix B.\n\nReference: Ringbauer, H., Coop, G., & Barton, N. H. (2017). Genetics, 205(3), 1335–1351.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.preprocess_dataset-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, AbstractVector, Real}","page":"Reference","title":"IdentityByDescentDispersal.preprocess_dataset","text":"preprocess_dataset(ibd_blocks::DataFrame, dist_matrix::AbstractMatrix, bins::AbstractVector, min_length::Real)\n\nPreprocesses the input data for identity-by-descent (IBD) block analysis.\n\nibd_blocks: DataFrame containing IBD blocks with columns ID1, ID2, and span. The ID1 and ID2 columns should contain the IDs of the individuals involved in the IBD block, and the span column should contain the length of the IBD block in Morgans.\nindividual_distances: DataFrame containing distances between individuals with columns ID1, ID2, and distance. The ID1 and ID2 columns should contain the IDs of the individuals involved in the distance. Notice that the units of the estimated density and dispersal rate will match the units of the distances provided.\nbins: A vector of right bins for the IBD blocks.\nmin_length: Minimum length of IBD blocks to consider in Morgans.\n\nIt returns a DataFrame in \"long\" format with the following columns:\n\nDISTANCE: The pairwise distance bin between individuals.\nIBD_LEFT: The left bound of the IBD length bin.\nIBD_RIGHT: The right bound of the IBD length bin.\nIBD_MID: The center of the IBD length bin.\nNR_PAIRS: The number of unique individual pairs within that distance.\nCOUNT: The number of IBD blocks observed in the corresponding bin.\nDISTANCE_INDEX: The index of the distance bin.\nIBD_INDEX: The index of the IBD length bin.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#IdentityByDescentDispersal.probability_coalescence-Tuple{Real, Real, Function, Real}","page":"Reference","title":"IdentityByDescentDispersal.probability_coalescence","text":"probability_coalescence(t::Real, r::Real, De::Function, sigma::Real)\n\nComputes the probability phi(t) that two homologous loci coalesce t generations ago according to\n\nphi(t) = frac12D_e(t) frac14pi t sigma^2 exp(frac-r^24 t sigma^2)\n\nRingbauer, H., Coop, G. & Barton, N.H. Genetics 205, 1335–1351 (2017).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#IdentityByDescentDispersal.safe_adbesselk-Tuple{Any, Any}","page":"Reference","title":"IdentityByDescentDispersal.safe_adbesselk","text":"x = safe_adbesselk(1, 1.0)\n\nA wrapper around the adbesselk to compute the modified Bessel function of the second kind of degree that returns a NaN if computation fails.\n\n\n\n\n\n","category":"method"},{"location":"#IdentityByDescentDispersal","page":"Home","title":"IdentityByDescentDispersal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for IdentityByDescentDispersal.","category":"page"},{"location":"tutorial/#Getting-started","page":"Tutorial","title":"Getting started","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates basic usage of the package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using IdentityByDescentDispersal","category":"page"},{"location":"tutorial/#Expected-number-of-identity-by-descent-blocks","page":"Tutorial","title":"Expected number of identity-by-descent blocks","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main feature of this package is to compute the expected number of identity-by-descent blocks under different demographic scenarios. For example, we might explore how fast the number of blocks decay as a function of physical distance between pairs of individuals.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\nL = 0.01         # Block length threshold (in Morgans)\nG = 0.01         # Genome length (in Morgans)\nD = 1.0          # Effective population density\nσ = 1.0          # Dispersal rate\nr_values = range(0.01, 25.0, length = 200);  # Distances\n\nplot(\n    r_values,\n    expected_ibd_blocks_constant_density.(r_values, 1.0, 0.5, L, G),\n    xlabel = \"Distance (r)\",\n    ylabel = \"E[IBD blocks]\",\n    title = \"Constant effective density scenario\",\n    label = \"D=1.0, σ=0.5\",\n)\nplot!(\n    r_values,\n    expected_ibd_blocks_constant_density.(r_values, 2.0, 0.5, L, G),\n    label = \"D=2.0, σ=0.5\",\n)\nplot!(\n    r_values,\n    expected_ibd_blocks_constant_density.(r_values, 1.0, 0.8, L, G),\n    label = \"D=1.0, σ=0.8\",\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition to constant effective densities and power density functions, we also support arbitrary effective density functions provided by the user via numerical integration. Next, we illustrate how to define a custom function by considering a scenario with an oscillating effective density function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function De(t, θ)\n    D₀, a, ω = θ\n    D₀ * (1 + a * sin(ω * t))\nend\n\nθ = [1.0, 0.5, 2π]  # Parameters for De(t): D₀, a, ω\nt_values = range(0.0, 10.0, length = 200)   # Time for plotting D_e(t)\nibd_values = [expected_ibd_blocks_custom(r, De, θ, σ, L, G) for r in r_values]\ndensity_values = [De(t, θ) for t in t_values]\nplot(\n    plot(\n        t_values,\n        density_values,\n        xlabel = \"Time (t)\",\n        ylabel = \"Effective Density Dₑ(t)\",\n        label = \"θ = [D₀=1, a=0.5, ω=2π]\",\n        title = \"Effective Density Trajectory\",\n    ),\n    plot(\n        r_values,\n        ibd_values,\n        xlabel = \"Distance (r)\",\n        ylabel = \"E[IBD blocks]\",\n        label = \"σ = 0.5, L = 0.01, G = 0.01\",\n        title = \"Expected Number of IBD Blocks\",\n    ),\n    layout = (2, 1),\n    size = (600, 800),\n    title = \"User-defined effective density function\",\n)","category":"page"},{"location":"tutorial/#Inference","page":"Tutorial","title":"Inference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ringbauer proposed to do inference by assuming that the observed number of IBD blocks that a pair r units apart that fall within a small bin L_i L_i + Delta L follows a Poisson distribution with mean EN_L_i(r theta) Delta L.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Therefore, the log probability of observing Y identity-by-descent blocks whose length fall in the bin L_i L_i + Delta L from a pair of individuals that are r units apart can be calculated simply as:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Distributions\nλ = expected_ibd_blocks_constant_density(\n    0.2, # Distance,\n    0.5, # Dispersal rate\n    2.0, # Effective density\n    0.01, # Block length threshold (in Morgans)\n    1.0, # Genome length (in Morgans)\n)\nY = 5 # Observed number of IBD blocks\nlogpdf(Poisson(λ), Y)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The inference scheme is based on a composite-likelihood that treats each bin from different pairs of individuals as independent. For computational reasons, it is also faster to aggregate observations that correspond to the same distance and bin.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The input data for this sort of analysis is:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A DataFrame containing the length of identity-by-descent blocks shared across different individuals\nA DataFrame containing distances across pairs of individuals.\nA list of contig lengths to properly take into account chromosomal edges (in Morgans).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Preprocessing the data requires combining the different sources of information and binning the identity-by-descent blocks. For this purpose, we provide a helper function that returns a DataFrame in a \"long\" format.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DataFrames\nibd_blocks = DataFrame(\n    ID1 = [\"A\", \"B\", \"A\", \"C\", \"B\"],\n    ID2 = [\"B\", \"A\", \"C\", \"A\", \"C\"],\n    span = [0.005, 0.012, 0.21, 0.10, 0.08], # Morgans\n)\nindividual_distances = DataFrame(\n    ID1 = [\"A\", \"A\", \"B\"],\n    ID2 = [\"B\", \"C\", \"C\"],\n    distance = [10.0, 20.0, 10.0], # (e.g., in kilometers)\n)\ncontig_lengths = [1.0, 1.5] # Contig lengths (in Morgans)\nbins = [0.01, 0.02, 0.03] # Right edges of bins (in Morgans)\nmin_length = 0.005 # Minimum IBD length to consider\ndf = preprocess_dataset(ibd_blocks, individual_distances, bins, min_length)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now use the df DataFrameto compute composite loglikelihoods of different parameters using the family of composite_loglikelihood_* functions. The second major feature of this package is that functions are all compatible with automatic differentiation. Analytical solutions depend on a modified Bessel function of the second kind, which is not widely implemented in a way that allows for automatic differentiation . Here, we rely on the BesselK.jl package for doing this. In addition, we rely on the system of QuadGK.jl for numerical integration compatible with automatic differentiation. This allows us to perform gradient-based optimization and interact with existing software.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We recommend using this package together with the Turing.jl, as it provides a convenient interface for Bayesian and frequentist inference.","category":"page"},{"location":"tutorial/#Maximum-likelihood-estimation","page":"Tutorial","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, we can estimate the parameters of a constant density model using maximum likelihood estimation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Turing, StatsBase, StatsPlots\n@model function constant_density(df, contig_lengths)\n    D ~ Uniform(0, 100)\n    σ ~ Uniform(0, 20)\n    Turing.@addlogprob! composite_loglikelihood_constant_density(D, σ, df, contig_lengths)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Generate a MLE estimate.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mle_estimate = maximum_likelihood(constant_density(df, contig_lengths))\nDataFrame(coeftable(mle_estimate)) # computed from the Fisher information matrix","category":"page"},{"location":"tutorial/#Bayesian-inference","page":"Tutorial","title":"Bayesian inference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, we can do a standard Bayesian inference with any of the available inference algorithms such as NUTS. Here, we fit a power-density model using NUTS:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@model function power_density(df, contig_lengths)\n    D ~ Truncated(Normal(100, 20), 0, Inf)\n    σ ~ Truncated(Normal(1, 0.1), 0, Inf)\n    β ~ Normal(0, 0.5)\n    Turing.@addlogprob! composite_loglikelihood_power_density(D, β, σ, df, contig_lengths)\nend\nm = power_density(df, contig_lengths)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Sample 4 chains in a serial fashion.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"chains = sample(m, NUTS(), MCMCSerial(), 1000, 4)\nplot(chains)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"More complex models can be built with cautious consideration of identifiability. For example, we can fit a piecewise exponential density model using a custom function and numerical integration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function piecewise_D(t, parameters)\n    De1, De2, alpha, t0 = parameters\n    t <= t0 ? De1*exp(-alpha*t) : De2\nend\n@model function exponential_density(df, contig_lengths)\n    De1 ~ Truncated(Normal(1000, 100), 0, Inf)\n    De2 ~ Truncated(Normal(1000, 100), 0, Inf)\n    α ~ Normal(0, 0.05)\n    t0 ~ Truncated(Normal(500, 100), 0, Inf)\n    σ ~ Truncated(Normal(1, 0.1), 0, Inf)\n    theta = [De1, De2, α, t0]\n    Turing.@addlogprob! composite_loglikelihood_custom(\n        piecewise_D,\n        theta,\n        σ,\n        df,\n        contig_lengths,\n    )\nend\nm = exponential_density(df, contig_lengths)\nchain = sample(m, NUTS(), 1000;)\nDataFrame(summarize(chain))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
