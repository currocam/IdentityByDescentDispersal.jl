var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#IdentityByDescentDispersal.composite_loglikelihood_constant_density","page":"Reference","title":"IdentityByDescentDispersal.composite_loglikelihood_constant_density","text":"composite_loglikelihood_constant_density(D::Real, sigma::Real, df::DataFrame, contig_lengths::AbstractArray{<:Real}, chromosomal_edges::Bool=true, diploid::Bool=true) -> Real\n\nComputes the composite log-likelihood of the observed IBD blocks under a model with constant population density.\n\nD: Effective population density (diploid individuals per unit area).\nsigma: Root mean square dispersal distance per generation.\ndf: DataFrame containing the observed IBD blocks in the format returned by preprocess_dataset.\ncontig_lengths: Array of contig lengths in Morgans.\n\nOptionally:\n\nchromosomal_edges: Whether to account for chromosomal edge effects.\ndiploid: Whether to account for diploidy.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.composite_loglikelihood_custom","page":"Reference","title":"IdentityByDescentDispersal.composite_loglikelihood_custom","text":"composite_loglikelihood_custom(De::Function, parameters::AbstractArray, sigma::Real, df::DataFrame, contig_lengths::AbstractArray{<:Real}, chromosomal_edges::Bool=true, diploid::Bool=true) -> Real\n\nComputes the composite log-likelihood of the observed IBD blocks under a model with constant population density.\n\nDe is  a user-defined function that takes time t and parameters and returns the effective population density at time t.\nparameters is a user-defined array of parameters that the function De depends on.\nsigma: Root mean square dispersal distance per generation.\ndf: DataFrame containing the observed IBD blocks in the format returned by preprocess_dataset.\ncontig_lengths: Array of contig lengths in Morgans.\n\nOptionally:\n\nchromosomal_edges: Whether to account for chromosomal edge effects.\ndiploid: Whether to account for diploidy.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.composite_loglikelihood_power_density","page":"Reference","title":"IdentityByDescentDispersal.composite_loglikelihood_power_density","text":"composite_loglikelihood_power_density(D::Real, beta::Real, sigma::Real, df::DataFrame, contig_lengths::AbstractArray{<:Real}, chromosomal_edges::Bool=true, diploid::Bool=true) -> Real\n\nComputes the composite log-likelihood of the observed IBD blocks under a model with constant population density.\n\nD: Effective population density (diploid individuals per unit area).\nbeta is the power of the density function,\nsigma: Root mean square dispersal distance per generation.\ndf: DataFrame containing the observed IBD blocks in the format returned by preprocess_dataset.\ncontig_lengths: Array of contig lengths in Morgans.\n\nOptionally:\n\nchromosomal_edges: Whether to account for chromosomal edge effects.\ndiploid: Whether to account for diploidy.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.default_ibd_bins-Tuple{}","page":"Reference","title":"IdentityByDescentDispersal.default_ibd_bins","text":"default_ibd_bins()\n\nReturns the default bins used in Ringbauer et. al. for identity-by-descent (IBD) block analysis, as well as the minimum length of IBD blocks to consider in Morgans.\n\nRingbauer, H., Coop, G. & Barton, N.H. Genetics 205, 1335–1351 (2017).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#IdentityByDescentDispersal.expected_ibd_blocks_constant_density","page":"Reference","title":"IdentityByDescentDispersal.expected_ibd_blocks_constant_density","text":"expected_ibd_blocks_constant_density(r::Real, D::Real, sigma::Real, L::Real, G::Real, chromosomal_edges::Bool=true, diploid::Bool=true) -> Real\n\nComputes the expected density of identity-by-descent (IBD) blocks of length L for a model with constant population density. This function returns the expected number of IBD blocks per pair of individuals and per unit of block length.\n\nmathbbEN_L = int_0^infty mathbbEN_L^t dt =\nfracG8pi D sigma^2\nleft(fracrsqrtL sigmaright)^2\nK_2left(fracsqrt2L  rsigmaright)\n\nwhere:\n\nr is the geographic distance between samples,\nD is the effective population density (diploid individuals per unit area),\nsigma is the root mean square dispersal distance per generation,\nL is the length of the IBD block (in Morgans),\nG is the total map length of the genome (in Morgans),\nK₂ is the modified Bessel function of the second kind of order 2.\n\nIf chromosomal_edges is true (the default), we account for chromosomal edge effects. If diploid is true, we multiply by a factor of 4 to account for the fact that each individual has two copies of each chromosome. For more details, see Appendix B.\n\nThere is a function overload that accepts a vector of G values and returns the aggregated expected number of IBD blocks.\n\nReference: Ringbauer, H., Coop, G., & Barton, N. H. (2017). Genetics, 205(3), 1335–1351.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.expected_ibd_blocks_custom","page":"Reference","title":"IdentityByDescentDispersal.expected_ibd_blocks_custom","text":"expected_ibd_blocks_custom(r::Real, De::Function, parameters::AbstractArray, sigma::Real, L::Real, G::Real, chromosomal_edges::Bool = true, diploid::Bool = true)\n\nComputes the expected density of identity-by-descent (IBD) blocks of length L for a model where the effective population density is given by a custom function De(t, parameters). This function returns the expected number of IBD blocks per pair of individuals and per unit of block length.\n\nmathbbEN_L = int_0^infty mathbbEN_L^t dt = int_0^infty mathbbEN_L^t dt  G  4t^2 exp(-2Lt) cdot Phi(t) dt\n\nThe integral is computed numerically using Gaussian-Legendre quadrature rules with the QuadGK package.\n\nwhere:\n\nr is the geographic distance between samples,\nDe is  a user-defined function that takes time t and a parameters and returns the effective population density at time t.\nparameters is a user-defined array of parameters that the function De depends on.\nsigma is the root mean square dispersal distance per generation,\nL is the length of the IBD block (in Morgans),\nG is the total map length of the genome (in Morgans),\nK₂ is the modified Bessel function of the second kind of order 2.\n\nIf chromosomal_edges is true (the default), we account for chromosomal edge effects. If diploid is true, we multiply by a factor of 4 to account for the fact that each individual has two copies of each chromosome. For more details, see Appendix B.\n\nReference: Ringbauer, H., Coop, G., & Barton, N. H. (2017). Genetics, 205(3), 1335–1351.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.expected_ibd_blocks_power_density","page":"Reference","title":"IdentityByDescentDispersal.expected_ibd_blocks_power_density","text":"expected_ibd_blocks_power_density(r::Real, D::Real, beta::Real, sigma::Real, L::Real, G::Real, chromosomal_edges::Bool = true, diploid::Bool = true)\n\nComputes the expected density of identity-by-descent (IBD) blocks of length L for a model with a power population density in the form of D(t) = D_0t^-beta This function returns the expected number of IBD blocks per pair of individuals and per unit of block length.\n\nmathbbEN_L = int_0^infty mathbbEN_L^t dt =\n2^frac-3beta2-3\nfracGpi D sigma^2\nleft(fracrsqrtL sigmaright)^(2+beta)\nK_2+betaleft(fracsqrt2L  rsigmaright)\n\nwhere:\n\nr is the geographic distance between samples,\nD is the effective population density (diploid individuals per unit area),\nbeta is the power of the density function,\nsigma is the root mean square dispersal distance per generation,\nL is the length of the IBD block (in Morgans),\nG is the total map length of the genome (in Morgans),\nK₂ is the modified Bessel function of the second kind of order 2.\n\nIf chromosomal_edges is true (the default), we account for chromosomal edge effects. If diploid is true, we multiply by a factor of 4 to account for the fact that each individual has two copies of each chromosome. For more details, see Appendix B.\n\nReference: Ringbauer, H., Coop, G., & Barton, N. H. (2017). Genetics, 205(3), 1335–1351.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#IdentityByDescentDispersal.preprocess_dataset-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, AbstractVector, Real}","page":"Reference","title":"IdentityByDescentDispersal.preprocess_dataset","text":"preprocess_dataset(ibd_blocks::DataFrame, dist_matrix::AbstractMatrix, bins::AbstractVector, min_length::Real)\n\nPreprocesses the input data for identity-by-descent (IBD) block analysis.\n\nibd_blocks: DataFrame containing IBD blocks with columns ID1, ID2, and span. The ID1 and ID2 columns should contain the IDs of the individuals involved in the IBD block, and the span column should contain the length of the IBD block in Morgans.\nindividual_distances: DataFrame containing distances between individuals with columns ID1, ID2, and distance. The ID1 and ID2 columns should contain the IDs of the individuals involved in the distance. Notice that the units of the estimated density and dispersal rate will match the units of the distances provided.\nbins: A vector of right bins for the IBD blocks.\nmin_length: Minimum length of IBD blocks to consider in Morgans.\n\nIt returns a DataFrame in \"long\" format with the following columns:\n\nDISTANCE: The pairwise distance between individuals.\nIBD_LEFT: The left bound of the IBD length bin.\nIBD_RIGHT: The right bound of the IBD length bin.\nIBD_MID: The center of the IBD length bin.\nNR_PAIRS: The number of unique individual pairs within that distance.\nCOUNT: The number of IBD blocks observed in the corresponding bin.\nDISTANCE_INDEX: The index of the distance bin.\nIBD_INDEX: The index of the IBD length bin.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#IdentityByDescentDispersal.probability_coalescence-Tuple{Real, Real, Function, Real}","page":"Reference","title":"IdentityByDescentDispersal.probability_coalescence","text":"probability_coalescence(t::Real, r::Real, De::Function, sigma::Real)\n\nComputes the probability phi(t) that two homologous loci coalesce t generations ago according to\n\nphi(t) = frac12D_e(t) frac14pi t sigma^2 exp(frac-r^24 t sigma^2)\n\nRingbauer, H., Coop, G. & Barton, N.H. Genetics 205, 1335–1351 (2017).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#IdentityByDescentDispersal.safe_adbesselk-Tuple{Any, Any}","page":"Reference","title":"IdentityByDescentDispersal.safe_adbesselk","text":"x = safe_adbesselk(1, 1.0)\n\nA wrapper around the adbesselk to compute the modified Bessel function of the second kind of degree that returns a NaN if computation fails.\n\n\n\n\n\n","category":"method"},{"location":"overview/#Theory-overview","page":"Theory overview","title":"Theory overview","text":"","category":"section"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"This package provides an efficient implementation of the inference scheme proposed by Ringbauer et al. ( 2017) to estimate the mean dispersal rate and the effective population density of a population. Here, we present an overview of the theory behind the method, but we refer to the original publication for details.","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"Mates tend to live close to each other and their offspring. This results in an inverse correlation between geographical distance and genetic relatedness. The goal of this package is to do demographic inference in such spatial genetic patterns.","category":"page"},{"location":"overview/#Diffusion-approximation-of-dispersal","page":"Theory overview","title":"Diffusion approximation of dispersal","text":"","category":"section"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"First, let’s provide some intuition on how we model the dispersal of individuals in a continuous space. From an ecological standpoint, we might be interested in the details of the single-generation dispersal, such as modeling the mating process or differences in dispersal across individuals and sexes. This is, however, not generally feasible to estimate from genetic data. Instead, we aim to estimate the mean dispersal rate across generations.","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"This method approximates the spatial movement of genetic material using a diffusion process. Let’s denote as r(t) the distance between two homologous loci at time t. First, recall that when t=TMRCA (time to the most common recent ancestor), then r(textTMRCA) = 0. The distance between both loci at the present, r(0)=r_textobs (i.e. the distance we can observe), is the sum of the sequence of migration events since the time to the most common recent ancestor.","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"If migrations are independent and identically distributed, then the random variable r_textobs converges to its own Gaussian distribution with axial variance of sigma^2cdot textTMRCA as textTMRCA grows according to the central-limit theorem. Here sigma^2 is the average squared axial parent-offspring distance (i.e. the dispersal rate).","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"This result is independent of the details of the single-generation dispersal process, while the variance is finite. For example, let’s consider a population where the single-generation dispersal can be modeled as a uniform distribution. Below, we visualize the distribution of distances between homologous loci when $ t = 1$ (single-generation dispersal) and $ t=30$. For simplicity, we assume a 1-dimensional space. As we can see, the approximation becomes very accurate even after a few generations.","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"using Distributions, Plots, StatsPlots\ndisplacement = Uniform(-1, 1)\nσ2 = var(displacement) # Theoretical variance of displacement\ndistance(t) = sum(rand(displacement, t)); # Distance after t migrations\nn_draws = 10_000\np1 = histogram(\n    [distance(1) for _ = 1:n_draws],\n    normalize = true,\n    label = \"t = 1\",\n    xlabel = \"Distance\",\n    ylabel = \"Density\",\n)\nplot!(p1, Normal(0, sqrt(σ2 * 1)), lw = 2, label = \"Gaussian Approximation\")\n\np2 = histogram(\n    [distance(30) for _ = 1:n_draws],\n    normalize = true,\n    label = \"t = 30\",\n    xlabel = \"Distance\",\n    ylabel = \"Density\",\n)\nplot!(p2, Normal(0, sqrt(σ2 * 30)), lw = 2, label = \"Gaussian Approximation\")\nplot(p1, p2, layout = (1, 2), size = (900, 400), legend = :topright, framestyle = :box)","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"This approximation is expected to work well in regimes where the time to the most common recent ancestor is not extremely small and when migrations are not correlated and time-homogeneous (i.e. they are independent and identically distributed).","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"From the previous section, it is clear that it would be possible to design an inference scheme based on the diffusion approximation if we knew the exact time to the most recent common ancestor between homologous loci. For example, the probability of two homologous loci being one unit apart given that they coalesced 20 generations ago can be calculated from the probability density of the Gaussian approximation for any σ.","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"pdf(Normal(0, sqrt(σ2 * 20)), 1)","category":"page"},{"location":"overview/#Coalescent-theory","page":"Theory overview","title":"Coalescent theory","text":"","category":"section"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"However, the time to the most common recent ancestor is not directly observable. Instead, what we can do is marginalize across all possible times 0 infty). Here is when coalescent theory is used to model the probabilities of coalescent events. Roughly speaking, we consider a scenario where two homologous loci might coalesce when they become very close. The rate with which they coalesce when they are very close is inversely proportional to local effective density D_e. According to this model, the probability that two homologous loci that are d units apart in the present coalesce at time t is simply the product of the probability that r(t) = 0 and a rate of local coalescence frac1D_e(t).","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"generations = 1:300\nD_e = 1 # Constant effective density of 1 (individuals per unit area)\nσ = 1 # Constant dispersal rate of 1( distance units per generation)\nr = 3 # Pairwise distance between loci\ndensities = [pdf(Normal(0, sqrt(σ^2 * t)), r) / D_e for t in generations]\nplot(\n    generations,\n    densities,\n    ylabel = \"Probability of coalescence ϕ(t)\",\n    xlabel = \"Generations\",\n    label = \"(D=1, σ=1, r=3)\",\n)","category":"page"},{"location":"overview/#IBD-blocks","page":"Theory overview","title":"IBD blocks","text":"","category":"section"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"The last ingredient of this method is the relationship between identity-by-descent blocks and time to the most recent common ancestor. First, we point out that generally only recent coalescent events are informative of the dispersal rate. This is the reason why this inference scheme relies on identity-by-descent blocks, as they can be used to model recent demography.","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"We say that a segment of DNA is a shared identity-by-descent block if it has been inherited from a common ancestor without being broken by recombination. A shared identity-by-descent block of length l that finds its common ancestor at time t has experienced 2t meiosis. Therefore, we expect l to decay with t.","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"More specifically, if we model recombination as a Poisson process and measure genetic distance in Morgans (as it is typically done), then the probability that a region of length $ L$ does not recombine follows the exponential distribution with rate exp(-2Lt)","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"Ringbauer et al. (2017) derived that the expected density of identity-by-descent blocks of length l per pair of haploid individuals and per unit of block length given that the time to the most recent common ancestor is t is given by EK_l  t approx G 4 t^2 exp(-2lt) where G is the length of the genome in Morgans. This equation is obtained by accounting for the probability that there is a region of length l that has not recombined (the exp(-2lt) term) and it is delimited by two recombination events (the 4 t^2 term) and summing across all possible start sites (the G factor). A slightly more complex expression that accounts for the effect of chromosomal edges and diploidy is provided in the article and the software implementation.","category":"page"},{"location":"overview/#Inference-scheme","page":"Theory overview","title":"Inference scheme","text":"","category":"section"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"As mentioned above, the inference scheme relies on computing the expected density of identity-by-descent blocks under a given demographic model. This involves marginalizing across all possible times of coalescence, therefore computing integrals in the form of","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"EL = int_0^infty EL  t phi(t) dt","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"where f(t) is the probability density function of the time to the most recent common ancestor. This expression is hard to track down analytically. Ringbauer et al. (2017) derived an analytical solution for a family of demographic models. Alternatively, this software implementation provides a numerical approximation of the integral using Gaussian-quadrature rules. We refer to the rest of the sections of the documentation for more details.","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"Ringbauer et al. (2017) proposed an inference scheme where they assumed the number of observed shared-identity-by-descent blocks  whose length fall in a small bin follows a Poisson distribution. The rate of the distribution can be calculated from the expected  density of identity-by-descent blocks under the demographic model of interest. If the bin is small enough, it can be simply calculated  as","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"$ E[L, L+\\Delta L ] = E[L] \\Delta L $","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"Finally, they propose to approximate the likelihood of the observed data across many bins and pairs of individuals using a composite  likelihood (that is, by assuming pairwise observations are independent).","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"L(theta  Y_i^j) = Pr(K = Y_i^j  EL_i^j Delta L)","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"where Y_i^j is the number of observed shared-identity-by-descent blocks whose length fall in the ith bin and are shared by the jth pair of individuals. The composite likelihood of all data is simply:","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"CL(theta  textData) = prod_ij Pr(K = Y_i^j  EL_i^j Delta L)","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"","category":"page"},{"location":"overview/","page":"Theory overview","title":"Theory overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#IdentityByDescentDispersal","page":"Home","title":"IdentityByDescentDispersal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for IdentityByDescentDispersal.","category":"page"},{"location":"tutorial/#Getting-started","page":"Tutorial","title":"Getting started","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates basic usage of the package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using IdentityByDescentDispersal","category":"page"},{"location":"tutorial/#Expected-density-of-identity-by-descent-blocks","page":"Tutorial","title":"Expected density of identity-by-descent blocks","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Genetic distances between populations are often a function of geographic distance. This phenomenon is often referred to as isolation-by-distance. Isolation-by-distance is reflected in the patterns of identity-by-descent blocks (also known as IBD blocks). It is possible to derive the expected patterns of shared identity-by-descent blocks under a diffusion approximation and certain demographic models. We refer to the publication of Ringbauer et al. (2017) and the Model overview section of the documentation for more details.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main feature of this package is to compute the expected density of identity-by-descent blocks under different demographic scenarios. Next, we show how to compute the expected density of identity-by-descent blocks under a constant population density using the expected_ibd_blocks_constant_density function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\nL = 0.01         # Block length threshold (in Morgans)\nG = 1.0          # Genome length (in Morgans)\nr_values = range(0.01, 25.0, length = 200);  # Distances\n\nplot(\n    r_values,\n    expected_ibd_blocks_constant_density.(r_values, 1.0, 0.5, L, G),\n    xlabel = \"Geographic distance between individuals (r)\",\n    ylabel = \"E[#IBD blocks per unit of block length and per pair]\",\n    title = \"Constant effective density scenario\",\n    label = \"D=1.0, σ=0.5\",\n)\nplot!(\n    r_values,\n    expected_ibd_blocks_constant_density.(r_values, 2.0, 0.5, L, G),\n    label = \"D=2.0, σ=0.5\",\n)\nplot!(\n    r_values,\n    expected_ibd_blocks_constant_density.(r_values, 1.0, 0.8, L, G),\n    label = \"D=1.0, σ=0.8\",\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The figure above shows how the density of IBD blocks of length 1 centimorgan in a genome of 1 Morgan decays as a function of geographic distance for different demographic scenarios that vary in effective density and dispersal rate. The effective density is in units of number of diploid individuals per area unit (e.g., km²). The dispersal rate is defined as the square root of the average squared axial parent-offspring distance. The rate of the decay of identity-by-descent blocks is directly related to the time since the most recent common ancestor.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Recall that the length of IBD blocks is a continuous random variable. Therefore, the expected number of IBD blocks of exactly length L is zero. What the expected_ibd_blocks_constant_density function returns is the expected number of IBD blocks of length L per unit of block length (in Morgans) and per pair. In order to compare such expectations with observed data, we often want to consider instead the expected number of blocks whose length falls in a given interval [a, b]. For a small enough interval L L + Delta L we can approximate the expected number of blocks whose length falls in that interval as:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"$ E[N{[L, L + \\Delta L]}] = \\int{L}^{L + \\Delta L} E[NL] dL \\approx E[NL] \\Delta L $","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, the expected number of identity-by-descent blocks whose length falls in the interval [1cM, 1.1cM] shared by two diploid individuals that are 1 kM apart in a population with constant effective population density of 10/kM²and dispersal rate of 0.5/kM would be","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"expected_ibd_blocks_constant_density(1.0, 10.0, 0.5, L, G) * 0.001","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ringbauer et al. (2017) derived analytical solutions for the expected density of identity-by-descent blocks for the family of functions of effective population density of the form D_e(t) = D_1 t^-beta. A constant effective population density is a special case of this family with beta = 1. For other values of beta, the expected density of identity-by-descent blocks can be computed using the expected_ibd_blocks_power_density function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition to power density functions, we also support arbitrary effective density functions provided by the user via numerical integration. Next, we illustrate how to define a custom function by considering the popular choice of an exponential growth function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"D = 1.0          # Effective population density\nσ = 1.0          # Dispersal rate\nfunction De(t, θ)\n    D₀, α = θ\n    max(D₀ * exp(-α * t), eps())\nend\nplot(\n    r_values,\n    [expected_ibd_blocks_custom(r, De, [D, 0.0], σ, L, G) for r in r_values],\n    xlabel = \"Geographic distance between individuals (r)\",\n    ylabel = \"E[#IBD blocks per unit of block length and per pair]\",\n    title = \"Constant effective density scenario\",\n    label = \"growth rate α = 0.0\",\n)\nplot!(\n    r_values,\n    [expected_ibd_blocks_custom(r, De, [D, 0.005], σ, L, G) for r in r_values],\n    label = \"growth rate α = 0.005\",\n)\nplot!(\n    r_values,\n    [expected_ibd_blocks_custom(r, De, [D, -0.005], σ, L, G) for r in r_values],\n    label = \"growth rate α = -0.005\",\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is possible to define more complex effective density functions. However, users should consider carefully whether such parameters are identifiable from identity-by-descent blocks if they aim to estimate them. As an example, we compare the one scenario with an oscillating effective density function with a constant effective density demography.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function De(t, θ)\n    D₀, a, ω = θ\n    D₀ * (1 + a * sin(ω * t))\nend\nD = 1.0          # Effective population density\nσ = 1.0          # Dispersal rate\nθ = [D, 0.5, 2π]  # Parameters for De(t): D₀, a, ω\nt_values = range(0.0, 10.0, length = 200)   # Time for plotting D_e(t)\np1 = plot(\n    t_values,\n    [De(t, θ) for t in t_values],\n    xlabel = \"Time (generations ago)\",\n    ylabel = \"Effective population density\",\n    label = \"Oscillating effective density\",\n)\nhline!(p1, [D], label = \"Constant effective density\")\np2 = plot(\n    r_values,\n    [expected_ibd_blocks_custom(r, De, θ, σ, L, G) for r in r_values],\n    xlabel = \"Geographic distance between individuals (r)\",\n    ylabel = \"E[#IBD blocks per unit of block length and per pair]\",\n    label = \"Oscillating effective density\",\n)\nplot!(\n    p2,\n    r_values,\n    [expected_ibd_blocks_constant_density(r, D, σ, L, G) for r in r_values],\n    label = \"Constant effective density\",\n)\n\nplot(p1, p2, layout = (2, 1), size = (600, 800))","category":"page"},{"location":"tutorial/#Inference","page":"Tutorial","title":"Inference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ringbauer et. al (2017) proposed to do inference by assuming that the observed number of IBD blocks that a pair r units apart that fall within a small bin L_i L_i + Delta L follows a Poisson distribution with mean EN_L_i(r theta) Delta L.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Therefore, the log probability of observing Y identity-by-descent blocks whose length fall in the bin L_i L_i + Delta L from a pair of individuals that are r units apart can be calculated simply as:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Distributions\nλ = expected_ibd_blocks_constant_density(\n    0.2, # Distance,\n    0.5, # Dispersal rate\n    2.0, # Effective density\n    0.01, # Block length threshold (in Morgans)\n    1.0, # Genome length (in Morgans)\n)\nY = 5 # Observed number of IBD blocks\nlogpdf(Poisson(λ), Y)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The inference scheme is based on a composite-likelihood that treats each bin from different pairs of individuals as independent. For computational reasons, it is also faster to aggregate observations that correspond to the same distance and bin.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The input data for this sort of analysis is:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A DataFrame containing the length of identity-by-descent blocks shared across different individuals.\nA DataFrame containing distances across pairs of individuals.\nA list of contig lengths to properly take into account chromosomal edges (in Morgans).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DataFrames\nibd_blocks = DataFrame(\n    ID1 = [\"A\", \"B\", \"A\", \"C\", \"B\"],\n    ID2 = [\"B\", \"A\", \"C\", \"A\", \"C\"],\n    span = [0.005, 0.012, 0.21, 0.10, 0.08], # Morgans\n)\nindividual_distances = DataFrame(\n    ID1 = [\"A\", \"A\", \"B\"],\n    ID2 = [\"B\", \"C\", \"C\"],\n    distance = [10.0, 20.0, 10.0], # (e.g., in kilometers)\n)\ncontig_lengths = [1.0, 1.5]; # Contig lengths (in Morgans)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Preprocessing the data requires combining the different sources of information and binning the identity-by-descent blocks. For this purpose, we provide a helper function preprocess_dataset that returns a DataFrame in a \"long\" format. Of course, you may specify your own bins, but here we use the same bins used by Ringbauer et al. (2017), which can be accessed via the default_ibd_bins function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bins, min_length = default_ibd_bins()\ndf = preprocess_dataset(ibd_blocks, individual_distances, bins, min_length);\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In most scenarios, distances between diploid individuals are not available, but between sampling sites. The preprocess_dataset function handles this scenario appropriately by aggregating observations from pairs that have the exact same distance. However, if distances are available at the individual level, you may consider binning them to reduce the runtime. You might find an example of this in the simulations subdirectory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now use the df DataFrameto compute composite log likelihoods of different parameters using the family of composite_loglikelihood_* functions. The second major feature of this package is that functions are all compatible with automatic differentiation. Analytical solutions depend on a modified Bessel function of the second kind, which is not widely implemented in a way that allows for automatic differentiation . Here, we rely on the BesselK.jl package for doing this. In addition, we rely on the system of QuadGK.jl for numerical integration compatible with automatic differentiation. This allows us to perform gradient-based optimization and interact with existing software.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We recommend using this package together with the Turing.jl, as it provides a convenient interface for Bayesian and frequentist inference.","category":"page"},{"location":"tutorial/#Maximum-likelihood-estimation","page":"Tutorial","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, we can estimate the parameters of a constant density model using maximum likelihood estimation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Turing, StatsBase, StatsPlots\n@model function constant_density(df, contig_lengths)\n    D ~ Uniform(0, 100)\n    σ ~ Uniform(0, 20)\n    Turing.@addlogprob! composite_loglikelihood_constant_density(D, σ, df, contig_lengths)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Generate a MLE estimate.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mle_estimate = maximum_likelihood(constant_density(df, contig_lengths))\nDataFrame(coeftable(mle_estimate)) # computed from the Fisher information matrix","category":"page"},{"location":"tutorial/#Bayesian-inference","page":"Tutorial","title":"Bayesian inference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, we can do a standard Bayesian inference with any of the available inference algorithms such as NUTS. Here, we fit a power-density model using NUTS:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@model function power_density(df, contig_lengths)\n    D ~ Truncated(Normal(100, 20), 0, Inf)\n    σ ~ Truncated(Normal(1, 0.1), 0, Inf)\n    β ~ Normal(0, 0.5)\n    Turing.@addlogprob! composite_loglikelihood_power_density(D, β, σ, df, contig_lengths)\nend\nm = power_density(df, contig_lengths)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Sample 4 chains in a serial fashion.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"chains = sample(m, NUTS(), MCMCSerial(), 1000, 4)\nplot(chains)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"More complex models can be built with cautious consideration of identifiability. For example, we can fit a piecewise exponential density model using a custom function and numerical integration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function piecewise_D(t, parameters)\n    De1, De2, alpha, t0 = parameters\n    t <= t0 ? De1 * exp(-alpha * t) : De2\nend\n@model function exponential_density(df, contig_lengths)\n    De1 ~ Truncated(Normal(1000, 100), 0, Inf)\n    De2 ~ Truncated(Normal(1000, 100), 0, Inf)\n    α ~ Normal(0, 0.05)\n    t0 ~ Truncated(Normal(500, 100), 0, Inf)\n    σ ~ Truncated(Normal(1, 0.1), 0, Inf)\n    theta = [De1, De2, α, t0]\n    Turing.@addlogprob! composite_loglikelihood_custom(\n        piecewise_D,\n        theta,\n        σ,\n        df,\n        contig_lengths,\n    )\nend\nm = exponential_density(df, contig_lengths)\nchain = sample(m, NUTS(), 1000;)\nDataFrame(summarize(chain))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
